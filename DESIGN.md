## More in-depth design decisions, if curious:

The bulk of the project was completed through the use of R. Within the file ari_data.R, I compiled and cleaned up the starting data. This involved making functions that utilized an HTML parser to get tracklists, lyrics, and billboard rankings from Genius.com and Billboard.com and string manipulations to make them more readable. I also did things like removing non-alphanumeric characters from the lyrics in order to facilitate the textual analyses I planned on doing. After having cleaned the data into a tidy data frame, I wrote the data to an RDS file to be used in the server of the web application. 

Within the file containing the code for the web app (ari/app.R), I wrote the user interfaces for the six tabs described in the README and then manipulated the data from the RDS file in order to create the plots, tables, and general functionality on the server side. The first tab entailed grouping the songs in the data by album and Billboard rank in order to compare albums by Top “n” songs (n chosen via user input). I started off with this simple table just to get the user introduced to what they will be exposed to in the rest of the app. Construction of the second tab entailed unnesting the lyrics into individual words and then finding the total number of words in each song and mapping it against either album or Billboard ranking based on user input. To make the third tab, I did something similar, except this time with number of unique lyrics. For the fourth tab, after unnesting the words, I got rid of “stop” words, which are common words like “the”, “a”, etc. because the goal was to find the most frequently used (but also non-trivial) words in her songs generally and in her albums. I did this by finding the count of each word, arranging the data in descending order, and then allowing the user to pick how many words get displayed in the bar graph. For the fifth plot, I used TF-IDF (term frequency-inverse document frequency) method, which is used to analyze documents and find the most important words. For this one, I filtered the words after unnesting to get rid of words with less than three characters, stop words, and other relatively meaningless words I noticed popping up after analysis (“ooh”, “you’ll”, etc.). To find the “importance” of each word, I applied a function “bind_tf_idf” that assigns a tf_idf (measure of importance) to each word and then I arranged the data in descending order based on tf_idf and made a bar graph with the data, allowing the user to select how many words are displayed on the graph and whether they want to filter by album. Finally, for the sixth plot, I unnested the lyrics into individual words, got rid of stop words, and then assigned each word “positive” or “negative” based on the “get_sentiments” function. Then, for each song, I computed the percentage of positive words used percentage positivity to compare Top 10, Top 100, and uncharted songs, and individual albums to each other, based on user input.

Overall, I tried to design the app in such a way that it would allow the user to see if there was potentially some correlation between factors like wordier/less wordy songs and Billboard rankings, lexical diversity and getting on the charts, etc., while also giving them to ability to see which qualities the albums shared or how they differed and potentially see how Ariana Grande, as an artist, has changed in these respects over time.
